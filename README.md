# code-plus

coding test

브루트 포스

- 모든 경우의 수를 다 해보는거
- 노가다로 다 구한다고 생각
- for, 재귀 등 반복문 이용
- 재귀쓰는게 뭔가 더 쉬워보이는 느낌.

다이나믹 프로그래밍

- 점화식
- 점화식을 이용해서 계속 답을 구하면 비효율
- 다른데 기록해서 중복호출이면 그냥 값을 가져오는 식으로 (memorization)
- 여러번 답을 구하는게 아닌 한번만 구하는 거로.
- 초기값, 점화식, 시간복잡도.

큐

- 한쪽에서 데이터 넣고, 다른쪽에서 빼는
- 한쪽에서 다른 한쪽
- push, pop ...

덱 -> 덱으로 큐, 스택을 만들면 된다.
그래서 파이썬의 경우 deque를 써서 나머지를 구현.
(아직 내가 코딩안해봐서 잘모름.)

- 어디서든 데이터 넣고, 아무데서나 뺄수있음.
- 양쪽에서 다 넣고 뺄수 있는.

그래프

- 정점 Vertex, 점
- 간선 Edge, 점과 점을 연결하는 선

- 경로, 어디에서 어디로 가는 경로
- 사이클, 경로 인데 시작 정점과 도착 정점이 같은 경우
- 경로와 사이클은 일반적으로 두번이상 방문하지 않는다. 이를 단순 경로, 단순 사이클이라고 함.

- 어떤 그래프내의 모든 간선이 방향을 가지면 다이렉트 그래프라고 함.(방향있는 그래프)
- 반대로 방향없는 그래프는 간선에 방향이 없고, 이를 양방향 그래프라고 부름.
- 루프, 간선의 양 끝 점이 같은 경우.

- 간선에 값이 있는 경우 가중치라 함.(거리, 시간, 비용 등의 의미)
- 가중치가 없는 경우 1이라고 생각하면 됨.

- 차수, 정점과 연결되어 있는 간선의 개수
- 방향이 있는 경우, In-degree(들어오는)), out-degree(나가는)로 표현.

그래프의 탐색

- 목적 : 한 정점에서 시작해서 연결된 모든 정점을 한 번씩 방문하는 것.

DFS, BFS

- 방문하는 순서의 차이
- 목적은 동일.

DFS

- 깊이 우선 탐색
- 시작점에서 한 명이 계속 이동하다가 갈 곳이 없으면 돌아가야 함.(스택)
- 재귀 호출

BFS

- 너비 우선 탐색
- 시작점에서 한명이 갈수있는 길을 복제해서 간다고 생각.
- 최단 경로는 무조건 BFS (가중치가 1인 경우만)
- 정점과 간선의 개수가 적어야 한다.

* 임의의 정점에서 시작해서 모든 정점을 한 번씩 방문하는 것 -> BFS,DFS

BFS -> 최단거리
